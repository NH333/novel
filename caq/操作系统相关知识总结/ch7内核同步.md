# 内核同步
**为啥要同步???**：解决并发带来的问题,多个执行线程同时访问和操作并发数据，就有可能发生各线程之间相互覆盖共享数据的情况，造成访问数据不一致状态。
## 基本概念
* 临界区（临界段）：访问和操作共享数据的代码段
* 竞争条件：两个执行线程处于同一个临界区中同时执行。
* 同步：避免并发和防止竞争条件为同步（synchronization）。

## 造成并发执行的原因：
* 1.中断
* 2.软中断和tasklet
* 3.内核抢占
* 4.睡眠及用户空间的同步
* 5.对称多处理

编码技巧：在编写代码的开始阶段就要设计恰当的锁，大多数内核数据都需要加锁。

## 死锁
### 死锁产生的条件：
要有一个或多个执行线程和一个或多个资源，每个线程都在等待其中的一个资源，但所有的资源都已经被占用。所有线程都在相互等待，但他们永远不会释放已经占有的资源。于是任何线程都无法继续，这便意味着死锁的发生。

### 避免死锁的一些手段：
* 1.按顺序加锁（最重要）
* 2.防止发生饥饿
* 3.不要重复请求同一个锁
* 4.设计应力求简单

```
按顺序加锁的例子

线程1            线程2
获得锁cat        获得锁fox
获得锁dog        试图获得锁dog
试图获得锁fox    等待锁dog
等待锁fox        ......
```
### 一些概念
* 锁的争用：当锁正在被占用时，其他线程试图获得该锁。
* 细粒度：描述加锁保护的数据规模。一个过粗的锁保护大块数据，一个过于精细的锁保护很小的一块数据。


## 内核同步的方法：
* 1.原子操作（原子整数操作，原子位操作）：不能够被分割的指令。通常是内联函数，通过内嵌汇编指令来实现。（例子，一个字长的读写不能同时进行）
    - 数字整数操作:只针对atomic_t数据类型，32位int型的低8位被嵌入了一个锁
    - 原子位操作：对普通的指针进行的操作

* 2.自旋锁（加锁时间不长并且代码不会睡眠（比如中断处理程序），禁止内核抢占）
* 3.读-写自旋锁

* 4.信号量（一种睡眠锁，加锁时间很长或者代码在持有锁时有可能睡眠，不会禁止内核抢占）
    - 计数信号量：允许在一个时刻至多有count（声明信号量时指定）个锁持有者
    - 互斥信号量（二值信号量）：在一个时刻仅允许有一个锁持有者
* 5.读-写信号量

* 6.互斥体
    ```
    mutex_init(&mutex)//动态初始化mutex

    mutex_lock(&mutex);
    /*临界区*/
    mutex_unlock(&mutex);
    ```
    #### **互斥体与信号量的区别**：优先使用互斥体，一般很底层的代码才会使用信号量
    #### **互斥体与自旋锁的区别**：中断上下文中只能使用自旋锁，而在任务睡眠时只能使用互斥体

* 7.完成变量

    内核中一个任务需要发出信号通知另一任务发生了某个特定事件

* 8.BLK：大内核锁（全局自旋锁）

    可以睡眠；递归锁；只可以用在进程上下文

* 9.顺序锁（seq锁）

    用于读写共享数据（数据存在很多读者；数据写者很少；写优于读；数据简单）
    jiffies：存储了linux机器启动到当前的时间

* 10.禁止抢占
    
    如果数据对于每个处理器来说是唯一的，就不需要自旋锁
    ```
    preempt_disable()
    //抢占被禁止
    preempt_enable()
    ```