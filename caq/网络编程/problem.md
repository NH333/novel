## Socket 编程

### 服务端和客户端构建的基本流程
```
服务端                                   客户端
1.socket()                              1.socket()
2.bind()                                2.connect()
3.listen()                              3.write()
4.accept()                              4.read()
5.read()                                5.close()
6.处理数据
7.write()给客户端
8.close()
```
### 几个要注意的函数
- socket() 在linux系统下是一种伪文件。
- bind() 绑定IP+Port，我们要知道服务端和客户端是两个socket(), 要向两者之间产生连接关系，就必须要用IP+port才能产生连接。
- listen() 指定最大同时发起连接数。内核给任何一个给定的监听套接字维护两个队列

    - 未完成连接队列(套接字状态：SYN_RCVD)
    - 已完成连接队列(套接字状态：ESTABLISHED)

    连接数的大小要考虑这两个队列的总和相关联。(参考UNIX网络编程84-85页)
- accept() 注意它的返回值，返回一个由内核生成的全新的文件描述符，称为**已连接套接字**描述符。它传入的第一个参数，是**监听套接字**描述符，它在该服务器的生命周期内一直存在。

### 几个需要注意的命令
- nc ip port 直接用来测试，与服务端的连接，可以简单的测试，而不需要写客户端程序
- netstat -apn | grep port 用来观察给定端口号的使用情况

### 协议
- 以太网帧 结构 arp协议，寻路，下一跳，路由表，NAT映射表，封装解封装的过程(视频P8)
    
    **每到一个路由就完成一次解包打包的操作（解以太网帧，IP数据报，根据拆出来的IP数据报中的目的端IP，从路由表中寻找下一跳合适的路由器，并把该路由器的IP地址给ARP，然后进行广播，得到下一跳的MAC地址），ARP帧数据的目的端IP是下一跳路由器的IP地址**
    
- MSS(maximum segment size) segment其实是报文段的意思，所以MSS指的是TCP报文段每次传输的最大数据分段大小。
- MTU(maximum transmission unit)最大传输单元，以太网帧中数据字段的大小最大为1500字节，该字段封装了[IP，TCP，数据]，所以，
```MSS = MTU - IP数据报头 - TCP报文段头```

### 问题
- read函数和recv函数的区别
- write函数和send函数的区别
- 慢速系统调用，快速系统调用：对于阻塞和非阻塞而言的